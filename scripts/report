#!/usr/bin/env python
# -*- coding: utf-8 -*-
################################################################################
##
## Copyright 2012 - 2016, GÃ¶teborg Bit Factory.
##
## Permission is hereby granted, free of charge, to any person obtaining a copy
## of this software and associated documentation files (the "Software"), to deal
## in the Software without restriction, including without limitation the rights
## to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:
##
## The above copyright notice and this permission notice shall be included
## in all copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
## OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
## THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
## OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.
##
## http://www.opensource.org/licenses/mit-license.php
##
################################################################################

import os
import sys
import re
import shutil
import json
import flod

################################################################################
# Stores the new digest event in the work tree.
# Combines all digest events into a commit-level JSON file.
# Combine all the commit-level JSON files into a report.
# Write the report to the work tree.
# Publish the report.
def main(event_file):
  event = flod.Event()
  event.load(event_file)
  config = flod.Config()

  # Create the work path, if necessary, and copy the digest event into the tree.
  commit_path = "{0}/{1}/{2}/{3}".format(config.get('work.dir'), event.header('change.project'), event.header('change.branch'), event.header('change.commit'))
  digest_file = "digest.{}.msg".format(event.header('platform.name'))

  if not os.path.exists(commit_path):
    os.makedirs(commit_path)

  shutil.copyfile(event_file, os.path.join(commit_path, digest_file))

  # If the 'commit.json' file exists, load it, else prime the header.
  commit_file = os.path.join(commit_path, "commit.json")
  if os.path.exists (commit_file):
    with open(commit_file) as fh:
      commit_json = json.load(fh)
  else:
    commit_json = {"repository": event.header("change.repository"),
                   "commit":     event.header("change.commit"),
                   "author":     event.header("change.author"),
                   "timestamp":  event.header("change.timestamp"),
                   "project":    event.header("change.project"),
                   "branch":     event.header("change.branch"),
                   "platforms":  {}}

  # Add the platform-specific results from the digest event.
  commit_json["platforms"][event.header("platform.name")] = dict()
  platform_node = commit_json["platforms"][event.header("platform.name")]

  platform_node["description"] = json.JSONEncoder().encode(event.header("platform.description"))
  platform_node["details"]     = json.JSONEncoder().encode(event.header("platform.details"))
  platform_node["skipped"]     = event.header("digest.testsSkipped")
  platform_node["passed"]      = event.header("digest.testsPassed")
  platform_node["failed"]      = event.header("digest.testsFailed")
  platform_node["expected"]    = event.header("digest.testsExpected")
  platform_node["warnings"]    = event.header("digest.buildWarnings")
  platform_node["errors"]      = event.header("digest.buildErrors")
  platform_node["log"]         = list()

  for line in event.payload().split('\n'):
    if len(line):
      platform_node["log"].append(json.JSONEncoder().encode(line))

  # Save the commit JSON file in the tree.
  with open(commit_file, 'w') as fh:
    fh.write(json.dumps(commit_json, sort_keys=True, indent=2, separators=(',', ': ')))

  # TODO Obtain the set of all platforms from configuration. If the commit_json
  #      dict shows zero failures/warnings from all platforms, post a 'clean'
  #      event.

  # Iterate over all the commit JSON files to create the report.
  all_commits = list()
  branch_path = "{0}/{1}/{2}".format(config.get('work.dir'), event.header('change.project'), event.header('change.branch'))
  for commit in os.listdir(branch_path):
    if len(commit) == 40: # Length of a SHA1.
      commit_json_file = os.path.join(branch_path, commit, 'commit.json')
      with open(commit_json_file) as fh:
        all_commits.append(json.load(fh))

  # Write the report.
  report_file = "{0}/{1}/{2}/report.html".format(config.get('work.dir'), event.header('change.project'), event.header('change.branch'))
  with open(report_file, 'w') as report:
    # Iterate over the commits in reverse timestamp order, and stop after fifty
    # commits.
    # TODO The '50' should come from configuration.
    counter = 0
    for commit in sorted(all_commits, reverse=True, key=lambda x:x["timestamp"]):
      counter += 1
      if counter > 50:
        break

      if counter == 1:
        report.write("# project {0} branch {1}\n".format(commit["project"], commit['branch']))

      report.write("# timestamp {0} commit {1} author {2}\n".format(commit["timestamp"], commit["commit"], commit["author"]))

      for platform in commit["platforms"]:
        report.write("#   platform {0} {1} {2}, {3}/{4}, {5} warnings, {6} errors\n".format(
                       platform,
                       commit["platforms"][platform]["description"],
                       commit["platforms"][platform]["details"],
                       commit["platforms"][platform]["passed"],
                       commit["platforms"][platform]["expected"],
                       commit["platforms"][platform]["warnings"],
                       commit["platforms"][platform]["errors"]))
        for error in commit["platforms"][platform]["log"]:
          report.write("#     error {0}\n".format(error))

  # Publish the report.
  publish_event = flod.Event()
  publish_event.header('from', report_file)
  publish_event.header('to', os.path.join(config.get('report.destination'), '{0}.{1}.html'.format(commit["project"], commit["branch"])))

  central = flod.Central()
  central.post('publish', publish_event)

################################################################################
# Entry point.  Checks only that there is one command line argument.
if __name__ == "__main__":
  """Flod2 hook script for building a tinderbox report from digest events."""

  if len(sys.argv) != 2:
    print "\nUsage: report <digest-event-file>\n\n"
    sys.exit(1)

  try:
    main(sys.argv[1])
  except Exception as msg:
    print('Error:', msg)

